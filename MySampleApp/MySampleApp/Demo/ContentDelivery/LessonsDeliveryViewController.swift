//
//  LessonsDeliveryViewController.swift
//  MySampleApp
//
//
// Copyright 2016 Amazon.com, Inc. or its affiliates (Amazon). All Rights Reserved.
//
// Code generated by AWS Mobile Hub. Amazon gives unlimited permission to 
// copy, distribute and modify it.
//
// Source code generated from template: aws-my-sample-app-ios-swift v0.4
//

import UIKit
import MediaPlayer
import AWSMobileHubHelper

class LessonsDeliveryViewController: UITableViewController {
    
    @IBOutlet weak var cacheLimitLabel: UILabel!
    @IBOutlet weak var currentCacheSizeLabel: UILabel!
    @IBOutlet weak var availableCacheSizeLabel: UILabel!
    @IBOutlet weak var pinnedCacheSizeLabel: UILabel!
    @IBOutlet weak var pathLabel: UILabel!
    
    private var prefix: String!
    private var marker: String?
    private var lessons: [AWSLesson]?
    private var didLoadAllLessons: Bool!
    
    private var manager: AWSLessonManager!
    private let dateFormatter: NSDateFormatter = NSDateFormatter()
    
    // MARK: - View lifecycle
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        manager = AWSLessonManager.defaultLessonManager()
        
        // Sets up the UIs.
        navigationItem.rightBarButtonItem = UIBarButtonItem(barButtonSystemItem: .Action, target: self, action: "showLessonManagerActionOptions:")
        
        // Sets up the date formatter.
        dateFormatter.dateStyle = .ShortStyle
        dateFormatter.timeStyle = .ShortStyle
        dateFormatter.locale = NSLocale.currentLocale()
        
        tableView.estimatedRowHeight = tableView.rowHeight
        tableView.rowHeight = UITableViewAutomaticDimension
        
        didLoadAllLessons = false
        updateUserInterface()
        loadMoreLessons()
    }
    
    private func updateUserInterface() {
        cacheLimitLabel.text = manager.maxCacheSize.aws_stringFromByteCount()
        currentCacheSizeLabel.text = manager.cachedUsedSize.aws_stringFromByteCount()
        availableCacheSizeLabel.text = (manager.maxCacheSize - manager.cachedUsedSize).aws_stringFromByteCount()
        pinnedCacheSizeLabel.text = manager.pinnedSize.aws_stringFromByteCount()
        
        if let prefix = self.prefix {
            pathLabel.text = prefix
        } else {
            pathLabel.text = "/"
        }
        tableView.reloadData()
    }
    
    // MARK: - Lessons Manager user action methods
    
    func showLessonManagerActionOptions(sender: AnyObject) {
        let alertController = UIAlertController(title: nil, message: nil, preferredStyle: .ActionSheet)
        
        let refreshAction = UIAlertAction(title: "Refresh", style: .Default, handler: {[unowned self](action: UIAlertAction) -> Void in
            self.refreshLessons()
            })
        alertController.addAction(refreshAction)
        let downloadObjectsAction = UIAlertAction(title: "Download Recent", style: .Default, handler: {[unowned self](action: UIAlertAction) -> Void in
            self.downloadObjectsToFillCache()
            })
        alertController.addAction(downloadObjectsAction)
        let changeLimitAction = UIAlertAction(title: "Set Cache Size", style: .Default, handler: {[unowned self](action: UIAlertAction) -> Void in
            self.showDiskLimitOptions()
            })
        alertController.addAction(changeLimitAction)
        let removeAllObjectsAction = UIAlertAction(title: "Clear Cache", style: .Destructive, handler: {[unowned self](action: UIAlertAction) -> Void in
            self.manager.clearCache()
            self.updateUserInterface()
            })
        alertController.addAction(removeAllObjectsAction)
        let cancelAction = UIAlertAction(title: "Cancel", style: .Cancel, handler: nil)
        alertController.addAction(cancelAction)
        presentViewController(alertController, animated: true, completion: nil)
    }
    
    private func refreshLessons() {
        marker = nil
        loadMoreLessons()
    }
    
    private func loadMoreLessons() {
        manager.listAvailableLessonsWithPrefix(prefix, marker: marker, completionHandler: {[weak self](lessons: [AWSLesson]?, nextMarker: String?, error: NSError?) -> Void in
            guard let strongSelf = self else { return }
            if let error = error {
                strongSelf.showSimpleAlertWithTitle("Error", message: "Failed to load the list of lessons.", cancelButtonTitle: "OK")
                print("Failed to load the list of lessons. \(error)")
            }
            if let lessons = lessons where lessons.count > 0 {
                strongSelf.lessons = lessons
                if let nextMarker = nextMarker where !nextMarker.isEmpty{
                    strongSelf.didLoadAllLessons = false
                } else {
                    strongSelf.didLoadAllLessons = true
                }
                strongSelf.marker = nextMarker
            }
            strongSelf.updateUserInterface()
            })
    }
    
    private func showDiskLimitOptions() {
        let alertController = UIAlertController(title: "Disk Cache Size", message: nil, preferredStyle: .ActionSheet)
        for number: Int in [1, 5, 20, 50, 100] {
            let byteLimitOptionAction = UIAlertAction(title: "\(number) MB", style: .Default, handler: {[unowned self](action: UIAlertAction) -> Void in
                self.manager.maxCacheSize = UInt(number) * 1024 * 1024
                self.updateUserInterface()
                })
            alertController.addAction(byteLimitOptionAction)
        }
        let cancelAction = UIAlertAction(title: "Cancel", style: .Cancel, handler: nil)
        alertController.addAction(cancelAction)
        presentViewController(alertController, animated: true, completion: nil)
    }
    
    private func downloadObjectsToFillCache() {
        manager.listRecentLessonsWithPrefix(prefix, completionHandler: {[weak self](result: AnyObject?, error: NSError?) -> Void in
            guard let strongSelf = self else { return }
            if let downloadResult: [AWSLesson] = result as? [AWSLesson] {
                for lesson: AWSLesson in downloadResult {
                    if !lesson.cached && !lesson.directory {
                        strongSelf.downloadLesson(lesson, pinOnCompletion: false)
                    }
                }
            }
            })
    }
    
    // MARK: - Lesson user action methods
    
    private func showActionOptionsForLesson(rect: CGRect, lesson: AWSLesson) {
        
        let alertController = UIAlertController(title: nil, message: nil, preferredStyle: .ActionSheet)
        if alertController.popoverPresentationController != nil {
            alertController.popoverPresentationController?.sourceView = self.view
            alertController.popoverPresentationController?.sourceRect = CGRectMake(rect.midX, rect.midY, 1.0, 1.0)
        }

        if lesson.cached {
            let openAction = UIAlertAction(title: "Open", style: .Default, handler: {[unowned self](action: UIAlertAction) -> Void in
                dispatch_async(dispatch_get_main_queue()) {
                    self.openLesson(lesson)
                }
                })
            alertController.addAction(openAction)
        }
        
        // Allow opening of remote files natively or in browser based on their type.
        let openRemoteAction = UIAlertAction(title: "Open Remote", style: .Default, handler: {[unowned self](action: UIAlertAction) -> Void in
            self.openRemoteLesson(lesson)
            })
        alertController.addAction(openRemoteAction)
        
        
        // If the lesson hasn't been downloaded, and it's larger than the limit of the cache,
        // we don't allow downloading the lessonn.
        if lesson.knownRemoteByteCount + 4 * 1024 < manager.maxCacheSize {
            // 4 KB is for local metadata.
            var title: String = "Download"
            if lesson.knownRemoteLastModifiedDate.compare(lesson.downloadedDate) == .OrderedDescending {
                title = "Download Latest Version"
            }
            
            let downloadAction = UIAlertAction(title: title, style: .Default, handler: {[unowned self](action: UIAlertAction) -> Void in
                self.downloadLesson(lesson, pinOnCompletion: false)
                })
            alertController.addAction(downloadAction)
        }
        
        let downloadAndPinAction = UIAlertAction(title: "Download & Pin", style: .Default, handler: {[unowned self](action: UIAlertAction) -> Void in
            self.downloadLesson(lesson, pinOnCompletion: true)
            })
        alertController.addAction(downloadAndPinAction)
        
        if lesson.cached {
            if lesson.pinned {
                let unpinAction = UIAlertAction(title: "Unpin", style: .Default, handler: {[unowned self](action: UIAlertAction) -> Void in
                    lesson.unPin()
                    self.updateUserInterface()
                    })
                alertController.addAction(unpinAction)
            } else {
                let pinAction = UIAlertAction(title: "Pin", style: .Default, handler: {[unowned self](action: UIAlertAction) -> Void in
                    lesson.pin()
                    self.updateUserInterface()
                    })
                alertController.addAction(pinAction)
            }
            let removeAction = UIAlertAction(title: "Delete Local Copy", style: .Destructive, handler: {[unowned self](action: UIAlertAction) -> Void in
                lesson.removeLocal()
                self.updateUserInterface()
                })
            alertController.addAction(removeAction)
        }
        
        let cancelAction = UIAlertAction(title: "Cancel", style: .Cancel, handler: nil)
        alertController.addAction(cancelAction)
        presentViewController(alertController, animated: true, completion: nil)
    }
    
    private func downloadLesson(lesson: AWSLesson, pinOnCompletion: Bool) {
        lesson.downloadWithDownloadType( .IfNewerExists, pinOnCompletion: pinOnCompletion, progressBlock: {[weak self](lesson: AWSLesson?, progress: NSProgress?) -> Void in
            guard let strongSelf = self else { return }
            if strongSelf.lessons!.contains( {$0 == lesson}) {
                let row = strongSelf.lessons!.indexOf({$0 == lesson})!
                let indexPath = NSIndexPath(forRow: row, inSection: 0)
                strongSelf.tableView.reloadRowsAtIndexPaths([indexPath], withRowAnimation: .None)
            }
            }, completionHandler: {[weak self](lesson: AWSLesson?, data: NSData?, error: NSError?) -> Void in
                guard let strongSelf = self else { return }
                if let downloadError: NSError = error {
                    print("Failed to download a lesson from a server.\(downloadError)")
                    strongSelf.showSimpleAlertWithTitle("Error", message: "Failed to download a lesson from a server.", cancelButtonTitle: "OK")
                }
                strongSelf.updateUserInterface()
            })
    }
    
    private func openLesson(lesson: AWSLesson) {
        if lesson.isAudioVideo() { // Video and sound files
            let directories: [AnyObject] = NSSearchPathForDirectoriesInDomains(.CachesDirectory, .UserDomainMask, true)
            let cacheDirectoryPath = directories.first as! String
            let movieURL = NSURL(fileURLWithPath: "\(cacheDirectoryPath)/\(lesson.key.getLastPathComponent())")
            lesson.cachedData.writeToURL(movieURL, atomically: true)
            let controller: MPMoviePlayerViewController = MPMoviePlayerViewController(lessonURL: movieURL)
            controller.moviePlayer.prepareToPlay()
            controller.moviePlayer.play()
            self.presentMoviePlayerViewControllerAnimated(controller)
        } else if lesson.isImage() {
            // Image files
            let storyboard = UIStoryboard(name: "LessonDelivery", bundle: nil)
            let imageViewController = storyboard.instantiateViewControllerWithIdentifier("LessonDeliveryImageViewController") as! LessonDeliveryImageViewController
            imageViewController.image = UIImage(data: lesson.cachedData)
            imageViewController.title = lesson.key
            navigationController?.pushViewController(imageViewController, animated: true)
        } else {
            showSimpleAlertWithTitle("Sorry!", message: "We can only open image, video, and sound files.", cancelButtonTitle: "OK")
        }
    }
    
    private func openRemoteLesson(lesson: AWSLesson) {
        lesson.getRemoteFileURLWithCompletionHandler({ (url: NSURL?, error: NSError?) -> Void in
            guard let url = url else {
                print("Error getting URL for file. \(error)")
                return
            }
            if lesson.isAudioVideo() { // Open Audio and Video files natively in app.
                let controller = MPMoviePlayerViewController(lessonURL: url)
                controller.moviePlayer.prepareToPlay()
                controller.moviePlayer.play()
                self.presentMoviePlayerViewControllerAnimated(controller)
            } else { // Open other file types like PDF in web browser.
                let storyboard = UIStoryboard(name: "LessonDelivery", bundle: nil)
                let webViewController = storyboard.instantiateViewControllerWithIdentifier("LessonDeliveryWebViewController") as! LessonDeliveryWebViewController
                webViewController.url = url
                webViewController.title = lesson.key
                self.navigationController?.pushViewController(webViewController, animated: true)
            }
        })
    }
    
    // MARK: - Table view data source
    
    override func numberOfSectionsInTableView(tableView: UITableView) -> Int {
        return 1
    }
    
    override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        if let lessons = self.lessons {
            return lessons.count
        }
        return 0
    }
    
    override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCellWithIdentifier("LessonDeliveryCell", forIndexPath: indexPath) as! LessonDeliveryCell
        let lesson = lessons![indexPath.row]
        cell.prefix = prefix
        cell.lesson = lesson
        return cell
    }
    
    override func tableView(tableView: UITableView, willDisplayCell cell: UITableViewCell, forRowAtIndexPath indexPath: NSIndexPath) {
        if let lessons = self.lessons {
            if indexPath.row == lessons.count - 1 {
                if (!didLoadAllLessons) {
                    loadMoreLessons()
                }
            }
        }
    }
    
    // MARK: - Table view delegate
    
    override func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {
        tableView.deselectRowAtIndexPath(indexPath, animated: true)
        let lesson = self.lessons![indexPath.row]
        if lesson.directory {
            let storyboard = UIStoryboard(name: "LessonDelivery", bundle: nil)
            let viewController = storyboard.instantiateViewControllerWithIdentifier("LessonDeliveryViewController") as! LessonsDeliveryViewController
            viewController.prefix = lesson.key
            navigationController!.pushViewController(viewController, animated: true)
        } else {
            let rowRect = tableView.rectForRowAtIndexPath(indexPath)
            showActionOptionsForLesson(rowRect, lesson: lesson)
        }
    }
}

class LessonDeliveryCell: UITableViewCell {
    
    @IBOutlet weak var fileNameLabel: UILabel!
    @IBOutlet weak var detailLabel: UILabel!
    @IBOutlet weak var keepImageView: UIImageView!
    @IBOutlet weak var downloadedImageView: UIImageView!
    @IBOutlet weak var progressView: UIProgressView!
    
    var prefix: String?
    var lesson: AWSLesson! {
        didSet{
            var displayFilename: String = lesson.key
            if let prefix: String = self.prefix {
                displayFilename = displayFilename.substringFromIndex(prefix.endIndex)
            }
            
            fileNameLabel.text = displayFilename
            downloadedImageView.hidden = !lesson.cached
            keepImageView.hidden = !lesson.pinned
            var lessonByteCount: UInt = lesson.fileSize
            if lessonByteCount == 0 {
                lessonByteCount = lesson.knownRemoteByteCount
            }
            
            if self.lesson.directory {
                detailLabel.text = "This is a folder"
                accessoryType = .DisclosureIndicator
            } else {
                detailLabel.text = lessonByteCount.aws_stringFromByteCount()
                accessoryType = .None
            }
            
            if lesson.knownRemoteLastModifiedDate.compare(lesson.downloadedDate) == .OrderedDescending {
                detailLabel.text = "\(detailLabel.text!) - New Version Available"
                detailLabel.textColor = UIColor.blueColor()
            } else {
                detailLabel.textColor = UIColor.blackColor()
            }
            
            if lesson.status == .Running {
                progressView.progress = Float(lesson.progress.fractionCompleted)
                progressView.hidden = false
            } else {
                progressView.hidden = true
            }
        }
    }
}

class LessonDeliveryImageViewController: UIViewController {
    
    @IBOutlet weak var imageView: UIImageView!
    var image: UIImage!
    
    override func viewWillAppear(animated: Bool) {
        super.viewWillAppear(animated)
        imageView.image = image
    }
}

class LessonDeliveryWebViewController: UIViewController, UIWebViewDelegate {
    
    @IBOutlet weak var webView: UIWebView!
    var url: NSURL!
    
    override func viewWillAppear(animated: Bool) {
        super.viewWillAppear(animated)
        webView.delegate = self
        webView.dataDetectorTypes = .None
        webView.scalesPageToFit = true
        webView.loadRequest(NSURLRequest(URL: url))
    }
    
    func webView(webView: UIWebView, didFailLoadWithError error: NSError?) {
        print("The URL lesson failed to load \(error)")
        webView.loadHTMLString("<html><body><h1>Cannot Open the lesson of the URL.</h1></body></html>", baseURL: nil)
    }
}

// MARK: - Utility

extension LessonsDeliveryViewController {
    private func showSimpleAlertWithTitle(title: String, message: String, cancelButtonTitle cancelTitle: String) {
        let alertController = UIAlertController(title: title, message: message, preferredStyle: .Alert)
        let cancelAction = UIAlertAction(title: cancelTitle, style: .Cancel, handler: nil)
        alertController.addAction(cancelAction)
        presentViewController(alertController, animated: true, completion: nil)
    }
}

extension AWSLesson {
    private func isAudioVideo() -> Bool {
        let lowerCaseKey = self.key.lowercaseString
        return lowerCaseKey.hasSuffix(".mov")
            || lowerCaseKey.hasSuffix(".mp4")
            || lowerCaseKey.hasSuffix(".mpv")
            || lowerCaseKey.hasSuffix(".3gp")
            || lowerCaseKey.hasSuffix(".mpeg")
            || lowerCaseKey.hasSuffix(".aac")
            || lowerCaseKey.hasSuffix(".mp3")
    }
    
    private func isImage() -> Bool {
        let lowerCaseKey = self.key.lowercaseString
        return lowerCaseKey.hasSuffix(".jpg")
            || lowerCaseKey.hasSuffix(".png")
            || lowerCaseKey.hasSuffix(".jpeg")
    }
}

extension UInt {
    private func aws_stringFromByteCount() -> String {
        if self < 1024 {
            return "\(self) B"
        }
        if self < 1024 * 1024 {
            return "\(self / 1024) KB"
        }
        if self < 1024 * 1024 * 1024 {
            return "\(self / 1024 / 1024) MB"
        }
        return "\(self / 1024 / 1024 / 1024) GB"
    }
}

extension String {
    private func getLastPathComponent() -> String {
        let nsstringValue: NSString = self
        return nsstringValue.lastPathComponent
    }
}
